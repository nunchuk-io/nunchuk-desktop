#!/usr/bin/env python3
import os
from pathlib import Path

QML_ROOT = Path("Qml")
OUTPUT_FILE = Path("features/generated_qml_registry.hpp")
OUTPUT_KEYS_FILE = Path("features/generated_qml_keys.hpp")

SCREEN_PREFIX = "qml.screens"
COMPONENT_PREFIX = "qml.components"

def make_key(path: Path) -> str:
    """
    Qml/Screens/LocalMode/SCR_ADD_HARDWARE_SIGNER.qml
    -> qml.screens.localmode.scr_add_hardware_signer
    """
    parts = list(path.parts)

    # remove "Qml"
    parts = parts[1:]

    # remove .qml
    parts[-1] = parts[-1].replace(".qml", "")

    parts = [p.lower() for p in parts]

    return ".".join(["qml"] + parts)


def make_value(path: Path) -> str:
    """
    All QML paths must use the qrc:/Qml/... prefix.
    """
    rel = str(path).replace("\\", "/")
    return f"qrc:/{rel}"


def collect_qml_files():
    return sorted(QML_ROOT.rglob("*.qml"))


def should_skip_key(key: str) -> bool:
    """Return True if the generated key should be excluded from the registry."""
    blocked = [
        "qml.global",
        "qml.components.origins",
        "qml.popups",
        "qml.core",
        "qml.components.customizes.popups",
        "qml.components.customizes.chats",
        "qml.components.customizes.buttons",

    ]
    # Skip exact matches and any nested keys under these prefixes
    return any(key == b or key.startswith(b + ".") for b in blocked)


def generate_entries():
    entries = []
    keys = []
    for qml in collect_qml_files():
        key = make_key(qml)
        if should_skip_key(key):
            continue
        value = make_value(qml)

        entries.append(
            f'{{ "{key}", "{value}" }}'
        )
        keys.append(key)
    return entries, keys


def write_header(entries):
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write("// AUTO-GENERATED FILE - DO NOT EDIT\n")
        f.write("// Generated by gen_qml_registry.py\n\n")
        f.write("#pragma once\n\n")
        f.write("#include <QHash>\n")
        f.write("#include <QString>\n\n")
        f.write("static const QHash<QString, QString> QML_REGISTRY = {\n")

        for e in entries:
            f.write(f"    {e},\n")

        f.write("};\n")


def _sanitize_identifier(s: str) -> str:
    # Allow only [a-z0-9_], replace others with '_'
    out = []
    for ch in s:
        if ch.isalnum() or ch == '_':
            out.append(ch)
        else:
            out.append('_')
    ident = ''.join(out)
    # Ensure it doesn't start with a digit
    if ident and ident[0].isdigit():
        ident = '_' + ident
    return ident


def write_keys_header(keys):
    # Writes macro-based namespace-qualified constants for each key
    with open(OUTPUT_KEYS_FILE, "w", encoding="utf-8") as f:
        f.write("// AUTO-GENERATED FILE - DO NOT EDIT\n")
        f.write("// Generated by gen_qml_registry.py\n\n")
        f.write("#pragma once\n\n")
        # Define macro for declaring qml keys inside a namespace path
        f.write("#ifndef QML_KEY_IN\n")
        f.write("#define QML_KEY_IN(ns, name, value) \\\nnamespace ns { \\\n    inline constexpr const char* name = value; \\\n}\n")
        f.write("#endif\n\n")
        # Generate one macro call per key
        for key in keys:
            parts = key.split('.')
            # Expect first part to be 'qml'
            if not parts or parts[0] != 'qml':
                continue
            ns_parts = parts[:-1]  # namespace path parts
            var_name = _sanitize_identifier(parts[-1])
            # Build C++ namespace path with '::'
            ns_path = "::".join(_sanitize_identifier(p) for p in ns_parts)
            # Emit macro usage
            f.write(f"QML_KEY_IN({ns_path}, {var_name}, \"{key}\");\n")


def main():
    if not QML_ROOT.exists():
        print("❌ Qml folder not found")
        return

    entries, keys = generate_entries()
    write_header(entries)
    write_keys_header(keys)

    print(f"✅ Generated {len(entries)} entries → {OUTPUT_FILE}")
    print(f"✅ Generated {len(keys)} constants → {OUTPUT_KEYS_FILE}")


if __name__ == "__main__":
    main()
